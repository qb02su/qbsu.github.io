{"meta":{"title":"qbsu' Blog","subtitle":"","description":"","author":"qbsu","url":"http://qbsu.fun","root":"/"},"pages":[{"title":"关于","date":"2020-02-18T08:35:01.373Z","updated":"2020-02-18T08:35:01.373Z","comments":true,"path":"about/index.html","permalink":"http://qbsu.fun/about/index.html","excerpt":"","text":"就读于杭州电子科技大学，一条咸鱼。 关于主题本站主题是：Material X"}],"posts":[{"title":"docker部署ElasticSearch","slug":"docker部署ElasticSearch","date":"2020-03-21T13:38:55.000Z","updated":"2020-03-22T08:17:17.659Z","comments":true,"path":"2020/03/21/docker部署ElasticSearch/","link":"","permalink":"http://qbsu.fun/2020/03/21/docker%E9%83%A8%E7%BD%B2ElasticSearch/","excerpt":"因为需要存储的数据不大，且基本上只有查找的需求，打算利用ElasticSearch来作为存储容器，因为没有Java环境，同时正好想学习下docker，就简单记录一下吧。 docker的安装及ElasticSearch的基本部署","text":"因为需要存储的数据不大，且基本上只有查找的需求，打算利用ElasticSearch来作为存储容器，因为没有Java环境，同时正好想学习下docker，就简单记录一下吧。 docker的安装及ElasticSearch的基本部署 一、docker安装1、创建一个新的仓库更新apt包 1$ sudo apt-get update 安装需要用到的包 123456$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 添加GPG key 1$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add - 2、下载Docker引擎1$ sudo apt-get install docker-ce docker-ce-cli containerd.io 跑一下helloworld镜像，验证是否安装成功 1$ sudo docker run hello-world 二、部署ElasticSearch1、拉取镜像1$ sudo docker pull docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.6.1 由于国内源速度很慢，这里需要用阿里云加速下","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://qbsu.fun/tags/docker/"}]},{"title":"Go Module的使用","slug":"Go-Module的使用","date":"2020-02-26T11:32:14.000Z","updated":"2020-02-26T12:01:35.653Z","comments":true,"path":"2020/02/26/Go-Module的使用/","link":"","permalink":"http://qbsu.fun/2020/02/26/Go-Module%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"Golang包管理器的学习","text":"Golang包管理器的学习 相较于过去的Go Path模式，Go Modules带来了以下特性： 自动下载依赖包 项目不必放在GOPATH/src内了 项目内会生成一个go.mod文件，列出包依赖 所以来的第三方包会准确的指定版本号 对于已经转移的包，可以用replace 申明替换，不需要改代码 创建项目首先在GOPATH/src以外的路径下新建一个项目文件，在该目录下命令行输入： 1go mod init hello 运行完后，会在当前项目目录下生成一个go.mod 文件，这是一个关键文件，之后的包的管理都是通过这个文件管理。 依赖包的安装如今， go 会自动查找代码中的包，下载依赖包，并且把具体的依赖关系和版本写入到go.mod和go.sum文件中。 依赖的第三方包被下载到了$GOPATH/pkg/mod路径下。 如果要想先下载依赖，那么可以直接像以前那样 go get 即可，不过 Go Mod 下可以跟语义化版本号，比如 go get package@v1.2.3 版本控制版本是在go.mod中指定的。 如果，在go.mod中没有指定，go命令会自动下载代码中的依赖的最新版本。 如果，在go.mod用require语句指定包和版本 ，go命令会根据指定的路径和版本下载包，指定版本时可以用latest，这样它会自动下载指定包的最新版本； 依赖包的版本号是什么？ 是包的发布者标记的版本号，格式为 vn.n.n (n代表数字)","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://qbsu.fun/tags/Go/"}]},{"title":"Go leetcode","slug":"go leetcode","date":"2020-02-18T07:34:40.000Z","updated":"2020-02-25T12:20:26.211Z","comments":true,"path":"2020/02/18/go leetcode/","link":"","permalink":"http://qbsu.fun/2020/02/18/go%20leetcode/","excerpt":"这里是用GO语言刷leetcode算法题的记录，会不定时更新","text":"这里是用GO语言刷leetcode算法题的记录，会不定时更新 1、两数之和（1）暴力求解法123456789101112131415161718192021func twoSum(nums []int, target int) []int &#123; res:&#x3D;make([]int,2,2) flag:&#x3D;0 for i1,v1 :&#x3D;range(nums)&#123; for i2,v2:&#x3D;range(nums)&#123; if i1&#x3D;&#x3D;i2&#123; continue &#125; if v1+v2&#x3D;&#x3D;target&#123; res[0]&#x3D;i1 res[1]&#x3D;i2 flag&#x3D;1 break &#125; &#125; if flag&#x3D;&#x3D;1&#123; break &#125; &#125; return res&#125; 时间复杂度为o(n^2),效率很差 （2）哈希表12345678910111213141516func twoSum(nums []int, target int) []int &#123; res:&#x3D;make([]int,2,2) hash:&#x3D;make(map[int]int) for i,v:&#x3D;range(nums)&#123; tempt:&#x3D;target-v _,ok:&#x3D;hash[tempt] if(ok)&#123; res[0]&#x3D;hash[tempt] res[1]&#x3D;i break &#125;else&#123; hash[v]&#x3D;i &#125; &#125; return res&#125; 利用数据类型map，将value和key置换，只需要一次O(n) + O(1) 即可 9.回文数1234567891011121314151617func isPalindrome(x int) bool &#123; var sum int&#x3D;0 var y int &#x3D;x if x&lt;0&#123; return false &#125; for x!&#x3D;0&#123; temp:&#x3D;x%10 sum&#x3D;sum*10+temp x&#x3D;x&#x2F;10 &#125; if sum&#x3D;&#x3D;y&#123; return true &#125;else&#123; return false &#125;&#125; 顺着题意把数字倒过来就行了 13.罗马数字转整数1234567891011121314151617func romanToInt(s string) int &#123; var sum int&#x3D;0 romanMap:&#x3D;map[string]int&#123;&quot;M&quot;:1000,&quot;CM&quot;:900,&quot;D&quot;:500,&quot;CD&quot;:400,&quot;C&quot;:100,&quot;XC&quot;:90,&quot;L&quot;:50,&quot;XL&quot;:40,&quot;X&quot;:10,&quot;IX&quot;:9,&quot;V&quot;:5,&quot;IV&quot;:4,&quot;I&quot;:1&#125; for i:&#x3D;0;i&lt;len(s);i++ &#123; if (i &lt; len(s)-1) &#123; _, ok :&#x3D; romanMap[s[i:i+2]] if ok &#123; sum +&#x3D; romanMap[s[i:i+2]] i++ &#125; else &#123; sum +&#x3D; romanMap[string(s[i])] &#125; &#125;else&#123; sum +&#x3D; romanMap[string(s[i])] &#125; &#125; return sum&#125; 切片范围是左闭右开给忘了-。- 14.最长公共前缀1234567891011121314151617181920212223func longestCommonPrefix(strs []string) string &#123; if len(strs) &#x3D;&#x3D; 0 &#123; return &quot;&quot; &#125; var result string if len(strs) &#x3D;&#x3D; 1 &#123; result &#x3D; strs[0] return result &#125; result &#x3D; strs[0] for i :&#x3D; 1; i &lt; len(strs); i++ &#123; if len(result)&gt;len(strs[i])&#123; result&#x3D;result[:len(strs[i])] &#125; for j:&#x3D;0;j&lt;len(result);j++&#123; if result[j]!&#x3D;strs[i][j]&#123; result&#x3D;result[:j] break &#125; &#125; &#125; return result&#125; 二维数组遍历下 20.有效的括号12345678910111213141516171819202122func isValid(s string) bool &#123; var stack []byte m:&#x3D;map[byte]byte&#123; &#39;)&#39;:&#39;(&#39;, &#39;]&#39;:&#39;[&#39;, &#39;&#125;&#39;:&#39;&#123;&#39;, &#125; for _,value:&#x3D;range s&#123; length:&#x3D;len(stack) if length&gt;0&#123; if _,ok:&#x3D;m[byte(value)];ok&#123; if stack[length-1]&#x3D;&#x3D;m[byte(value)]&#123; stack&#x3D;stack[:length-1] continue &#125; return false &#125; &#125; stack&#x3D;append(stack,byte(value)) &#125; return len(stack)&#x3D;&#x3D;0&#125; 21.合并两个有序链表1234567891011121314151617181920212223&#x2F;** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; *&#x2F;func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; head:&#x3D;&amp;ListNode&#123;&#125; newlist:&#x3D;head for l1!&#x3D;nil||l2!&#x3D;nil&#123; if l1&#x3D;&#x3D;nil||(l2!&#x3D;nil&amp;&amp;l1.Val&gt;l2.Val)&#123; newlist.Next&#x3D;l2 newlist&#x3D;l2 l2&#x3D;l2.Next &#125;else&#123; newlist.Next&#x3D;l1 newlist&#x3D;l1 l1&#x3D;l1.Next &#125; &#125; return head.Next&#125; 26. 删除排序数组中的重复项123456789101112131415func removeDuplicates(nums []int) int &#123; if len(nums)&#x3D;&#x3D;0 &#123; return 0 &#125; currValue :&#x3D; nums[0] count:&#x3D; 1 for i:&#x3D;0;i&lt;len(nums);i++ &#123; if nums[i] !&#x3D; currValue &#123; count ++ currValue &#x3D; nums[i] nums[count-1]&#x3D;currValue &#125; &#125; return count&#125; 27. 移除元素123456789101112func removeElement(nums []int, val int) int &#123; count :&#x3D; 0 for i:&#x3D;0;i&lt;len(nums);i++&#123; if nums[i]&#x3D;&#x3D;val&#123; continue &#125;else&#123; nums[count]&#x3D;nums[i] count++ &#125; &#125; return count&#125; 28. 实现 strStr()12345678910111213141516171819202122232425262728293031323334353637383940414243func getNext(s string) []int &#123; l :&#x3D; len(s) var next &#x3D; make([]int, l) &#x2F;&#x2F; 数组长度为模式串长度 next[0] &#x3D; -1 i :&#x3D; 0 j :&#x3D; -1 for i &lt; l-1 &#123; if j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; s[j] &#123; i +&#x3D; 1 j +&#x3D; 1 next[i] &#x3D; j &#125; else &#123; j &#x3D; next[j] &#125; &#125; return next&#125;func strStr(haystack string, needle string) int &#123; lh :&#x3D; len(haystack) ln :&#x3D; len(needle) if ln &lt; 1 &#123; return 0 &#125; if lh &lt; 1 &#123; return -1 &#125; i :&#x3D; 0 j :&#x3D; 0 next :&#x3D; getNext(needle) &#x2F;&#x2F; 构造next数组 for i &lt; lh &amp;&amp; j &lt; ln &#123; if j &#x3D;&#x3D; -1 || haystack[i] &#x3D;&#x3D; needle[j] &#123; i++ j++ &#125; else &#123; j &#x3D; next[j] &#x2F;&#x2F; 不匹配则则移动next[j]位 &#125; &#125; if j &#x3D;&#x3D; ln &#123; return i - j &#125; return -1&#125; KMP算法 167. 两数之和 II - 输入有序数组123456789101112131415161718func twoSum(numbers []int, target int) []int &#123; i:&#x3D;0; j:&#x3D;len(numbers)-1 result:&#x3D;make([]int,2,2) for i&lt;j&#123; sum:&#x3D;numbers[i]+numbers[j] if sum&lt;target&#123; i++ &#125;else if sum&gt;target&#123; j-- &#125;else&#123; result[0]&#x3D;i+1 result[1]&#x3D;j+1 return result &#125; &#125; return nil&#125; 633. 平方数之和123456789101112131415func judgeSquareSum(c int) bool &#123; i:&#x3D;0 j:&#x3D;int(math.Sqrt(float64(c))) for i&lt;&#x3D;j&#123; sum:&#x3D;i*i+j*j if sum&gt;c&#123; j-- &#125;else if sum&lt;c&#123; i++ &#125;else &#123; return true &#125; &#125; return false&#125; 345. 反转字符串中的元音字母123456789101112131415161718func reverseVowels(s string) string &#123; ss :&#x3D; []byte(s) tmp1 :&#x3D; &quot;aeiouAEIOU&quot; i :&#x3D; 0 j :&#x3D; len(s) - 1 for i &lt; j &#123; if strings.Contains(tmp1, string(ss[i])) &#123; if strings.Contains(tmp1, string(ss[j])) &#123; ss[i], ss[j] &#x3D; ss[j], ss[i] i++ &#125; j-- &#125; else &#123; i++ &#125; &#125; return string(ss)&#125; 141. 环形链表12345678910111213141516func hasCycle(head *ListNode) bool &#123; if head&#x3D;&#x3D;nil&#123; return false &#125; head1:&#x3D;head head2:&#x3D;head.Next for head1!&#x3D;nil&amp;&amp;head2!&#x3D;nil&amp;&amp;head2.Next!&#x3D;nil&#123; if head1.Next&#x3D;&#x3D;head2.Next&#123; return true &#125;else&#123; head1&#x3D;head1.Next head2&#x3D;head2.Next.Next &#125; &#125; return false&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://qbsu.fun/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://qbsu.fun/tags/%E7%AE%97%E6%B3%95/"},{"name":"go","slug":"go","permalink":"http://qbsu.fun/tags/go/"}]}]}